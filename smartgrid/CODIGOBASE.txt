###################################################################################################
# Step 1 : Setup initial basic graphics
# Step 2: Update available COMs & Baude rate
# Step 3: Serial connection setup
# Step 4: Dynamic GUI update
# Step 5: Testing & Debugging


##NOTAS
#PARA GENERAR EL EJECUTABLE
# INSTALE SERIAL Y PYSERIAL
# pip install serial
# pip install pyserial
# ACTUALIZAR LA VERSION DE PYSERIAL
## pip install pyserial==2.7
# EN EL CMD UBIQUESE EN LA CARPETA QUE CONTIENE EL ARCHIVO .PY A VOLVER EJECUTABLE
# si desea un icono personalizado para su aplicacion cree la imagen con extension .ico y guardela en la carpeta del proyecto
# instale pyinstaller
# pip install pyinstaller
# para crear el ejecutable use la siguiente linea de comandos
# pyinstaller --windowed --onefile --icon=./nombre_imagen.ico nombre_archivo_a_volver_ejecutable.py

# Nota si ya genero el .exe debe eliminar las carpetas, dist,build: _pycache_ antes de generar un nuevo .exe
###################################################################################################



from tkinter import *
import serial.tools.list_ports
import threading
from tkinter import messagebox

def Programa():
    #variables globales para permitir captura de datos en las diferentes funciones
    global root, BtnConectar, BtnBuscar,DatoRecibido,ValTemperatura,ValVoltaje
    # instanciar el objeto Tk para creacion de GUI
    root = Tk()
    root.title("JFCR")
    root.geometry("500x200")
    root.config(bg="#c0c0c0")
    root.resizable(0, 0)

    #ETIQUETAS PARA IDENTIFICAR A QUE CAMPO CORRESPONDE CADA ITEM
    LbPuerto = Label(root, text="Puertos Detectados: ", bg="#c0c0c0")
    LbPuerto.grid(column=1, row=1, pady=10, padx=10)

    LbBaudios = Label(root, text="Tasa de Baudios: ", bg="#c0c0c0")
    LbBaudios.grid(column=2, row=1, pady=10, padx=10)

    LbDbits = Label(root, text="Bits de Datos: ", bg="#c0c0c0")
    LbDbits.grid(column=3, row=1, pady=10, padx=10)

    # BOTONES PARA A GENERARA CONEXION SERIAL
    BtnBuscar = Button(root, text="Buscar Puertos", height=1, width=10, command=actualizar_puertos)
    BtnBuscar.grid(column=4, row=1)

    BtnConectar = Button(root, text="Conectar", height=1, width=10, state="disabled", command=Abrir_Puerto)
    BtnConectar.grid(column=4, row=2)

    #BtnEnviar = Button(root, text='Transmitir', height=1, width=10, command=writeserial(2, 3))
    BtnEnviar = Button(root, text='Transmitir', height=1, width=10, command=writeserial)
    BtnEnviar.grid(column=4, row=3)

    # LLAMADO INICIAL DE LAS FUNCIONES ACTUALIZAR_PUERTOS, TASA DE BAUDIOS Y BITS DE DATOS
    actualizar_puertos()
    Tasa_baudios()
    bits_datos()
    opc_activacion()

   # LABEL PARA IMPRIMIR DATOS Y VERIFICAR RECEPCION DE LOS MISMOS

    DatoRecibido=Label(root,text='---',bg="#c0c0c0")
    DatoRecibido.grid(column=3, row=4, pady=20, padx=10)

    LbTemperatura = Label(root, text='Temperatura', bg="#c0c0c0")
    LbTemperatura.grid(column=1, row=3, pady=20, padx=10)

    ValTemperatura=Label(root,text='00.00',bg="#c0c0c0")
    ValTemperatura.grid(column=1, row=4, pady=20, padx=10)

    LbVoltaje = Label(root, text='Voltaje', bg="#c0c0c0")
    LbVoltaje.grid(column=2, row=3, pady=20, padx=10)

    ValVoltaje = Label(root, text='00.00', bg="#c0c0c0")
    ValVoltaje.grid(column=2, row=4, pady=20, padx=10)
# verifica si se selecciono una opcion valida en el menu desplgable puertos,tasa de baudios y bits de datos,
def verificar_conexion(args):
    if "-" in pulso_actualizar.get() or "-" in pulso_baudios.get() or "-" in pulso_dbits.get() :
        BtnConectar["state"] = "disable"
    else:
        BtnConectar["state"] = "active"
#despliega el menu de opciones para activar cargas desde la interface de usuario
def opc_activacion():
    global pulso_activar, desplegar_activar
    pulso_activar = StringVar()
    activacion = ["1",
           "2",
           "3"]
    pulso_activar.set(activacion[0])
    desplegar_activar = OptionMenu(root, pulso_activar, *activacion)
    desplegar_activar.config(width=10)
    desplegar_activar.grid(column=3, row=3, padx=10)
# despliega el menu para seleccionar la tasa de baudios deseada
def Tasa_baudios():
    global pulso_baudios, desplegar_baudios
    pulso_baudios = StringVar()
    bds = ["-",
           "300",
           "600",
           "1200",
           "2400",
           "4800",
           "9600",
           "14400",
           "19200",
           "28800",
           "38400",
           "56000",
           "57600",
           "115200",
           "128000",
           "256000"]
    pulso_baudios.set(bds[0])
    desplegar_baudios = OptionMenu(root, pulso_baudios, *bds, command=verificar_conexion)
    desplegar_baudios.config(width=10)
    desplegar_baudios.grid(column=2, row=2, padx=10)
# despiega las opciones de bits de datos para la transmision
def bits_datos():
    global pulso_dbits, desplegar_dbits
    pulso_dbits = StringVar()
    dbits = ["-",
           "5",
           "6",
           "7",
           "8"]
    pulso_dbits.set(dbits[0])
    desplegar_dbits = OptionMenu(root, pulso_dbits, *dbits, command=verificar_conexion)
    desplegar_dbits.config(width=10)
    desplegar_dbits.grid(column=3, row=2, padx=10)
#despliega el menu de opciones para deteccion de puertos activos
def actualizar_puertos():
    global pulso_actualizar, desplegar_puertos
    #retorna en una lista los puertos detectados
    ports = serial.tools.list_ports.comports()
    #recorre la lista y asigna de forma dinamica los puertos encontrados
    coms = [com[0] for com in ports]
    coms.insert(0, "-")
    try:
        pulso_actualizar = StringVar()
        pulso_actualizar.set(coms[0])
        desplegar_puertos = OptionMenu(root, pulso_actualizar, *coms, command=verificar_conexion)
        desplegar_puertos.config(width=10)
        desplegar_puertos.grid(column=1, row=2, padx=10)
        verificar_conexion(0)
    except:
        desplegar_puertos.destroy()
        print("Error funcion update_coms")
#lee los datos encontrados en el puerto serial, la funcion esta corriendo en un hilo paralelo a la GUI
def readSerial(puerto_open):
    global serialData
    while serialData:
        data = puerto_open.readline()
        print(data)
        if len(data) > 0:
            try:
                trama_util = str(data)
                #quitar de a trama los caracteres que no son utiles, las letras mayusculas NO pueden ser eliminadas usando este metodo
                trama_filtrada = trama_util.strip("'b'\\r\\n")

                t = float(trama_filtrada[1:5])
                v = float(trama_filtrada[9:13])

                print(f'temperatura: {t}')
                print(f'voltaje {v}')
                #se crea hilo paralelo de ejecucion
                t2 = threading.Thread(target=imprimir_valor, args=(trama_util,t,v))
                t2.deamon = True
                t2.start()
            except:
                DatoRecibido.config(text="Error lectura del puerto serial")
                print("Error lectura del puerto serial")
#los datos capturados a traves del puerto serial son enviados a los label correspondientes
def imprimir_valor(trama,t,v):
    ValTemperatura.config(text=t)
    ValVoltaje.config(text=v)
    DatoRecibido.config(text=trama)
#escribir datos a traves del puerto serial
def writeserial():
    try:
        print(f'{pulso_activar.get()}'.encode())
        puerto_serial.write(f'{pulso_activar.get()}'.encode())
    except:
        print("Problemas envio")
#verificar el estado del texto del boton Conectar para abrir o cerrar el puerto segun corresponda
def Abrir_Puerto():
    global serialData, puerto_serial
    if BtnConectar["text"] in "Desconectar":
        serialData = False
        BtnConectar["text"] = "Conectar"
        BtnBuscar["state"] = "active"
        desplegar_baudios["state"] = "active"
        desplegar_puertos["state"] = "active"
        puerto_serial.close()

    else:
        serialData = True
        BtnConectar["text"] = "Desconectar"
        BtnBuscar["state"] = "disable"
        desplegar_baudios["state"] = "disable"
        desplegar_puertos["state"] = "disable"
        port = pulso_actualizar.get()
        baud = pulso_baudios.get()
        dbits =pulso_dbits.get()

        try:
            puerto_serial = serial.Serial(port=port, baudrate=int(baud), bytesize=int(dbits), timeout=None)
        except:
            print("Error funcion connexion")
        #se crea hilo de apertura de puertos seriales
        t1 = threading.Thread(target=readSerial, args=(puerto_serial,))
        t1.deamon = True
        t1.start()
#define la rutina para cierre de la ventana de la aplicacion al oprimir la opcion cerrar
def close_window():
    global root, serialData
    if messagebox.askokcancel("Quit", "Do you want to quit?"):
        serialData = False
        root.destroy()

Programa()
root.protocol("WM_DELETE_WINDOW", close_window)
root.mainloop()